Design:

1. On a node - topology

-  nodes are arranged in a ring
-  anti-clockwise node    > (NAB)   left signaller  >   Conveyor actor  > right signaller (NAB ) >      clockwise node
-  [ remote client/s ] > (NAB) client handler actor > Conveyor actor

2. Circulation

do nodes need to cycle jobs around the ring?
It's not essential but it is useful in the situation when workers connected to some of the nodes are starved of jobs, e.g. the situation where the number of workers >> number of submitters

3. Phasing

phase I: no circulation
phase 2: circulation



--------------------------------------------------------------------------
From: Payne, Jude
Sent: 22 October 2010 09:54
To: Groves, Paul; Watson, Sam


yes I thought about this also. I think it can be solved by:

empty pulses clockwise at interval M/n - the collision of empty pulse and copy pulse changes the state of copy pulse. empty pulse is destroyed - copy pulse continues anticlock with the extra bit of info - i.e. the bit that tells it that at some point the empty existed (i.e. the work was done).

From: Groves, Paul
Sent: Friday, October 22, 2010 9:48 AM
To: Payne, Jude; Watson, Sam


What if job is removed from queue and replaced with an empty.
The work is performed.
The node with empty, goes down.
The pulse notices the copy and no-job, and recreates the job, so the work is done twice.



From: Payne, Jude
Sent: 22 October 2010 09:46
To: Watson, Sam; Groves, Paul


one more state I thought of...& a correction

pulse meets job doesn't meet copy and is about to expire: (so 001 at expiry) -> reinstate copy

From: Payne, Jude
Sent: Friday, October 22, 2010 8:18 AM
To: Watson, Sam; Groves, Paul
Subject: 'The Belt'

- job submitted to node. node puts copy on node to the anticlockwise direction.
- job and copy both travel clockwise at intervals of M. if the node/s they are to be put on contain the other, they won't be moved.
- if a job is consumer, it is replaced by an empty, which keeps travelling clockwise with same constraints as above.
- copy sends out a 'pulse' anticlockwise at interval of M/n. n might for example be 4. pulse carries all state:
(in binary)
job = 001
empty = 010
copy = 100
in addition, the pulse counts the number of nodes it passes through (or keeps a list of nodes it has passed through. poss. better approach)

pulse has met job: 001 -> do nothing
pulse has met empty: 010 -> destroy empty
pulse has met job and (then) copy: 101 -> do nothing
pulse has met empty and then copy: 110 -> destroy copy, self
pulse meets copy (only): 100 -> reinstate [jpayne] job (essentially destroy copy & resubmit job (which recreates copy also)
if pulse moves > belt size (or pulse has been on a machine twice): -> destroy self

- pulses are generated by the copy so stop (shortly) after the copy has gone.
- multiple pulses are generated in the life of a typical copy, so the state itself is resilient.
- I think (but haven't reasoned through) that this scheme extends to having multiple copies (on 1 node anticlockwise & 2 nodes anticlockwise & etc...)

thoughts and problems?

Jude



